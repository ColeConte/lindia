#' cars_lm <- lm(Price ~ Passengers + Length + RPM, data = Cars93)
#' gg_cooksd(cars_lm)
#'
#' @export
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention") {
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
print(threshold)
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point() +
geom_linerange() +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 2, color = "indianred3")
}
if (show.threshold) {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3")
}
}
return(base_plot)
}
gg_cooksd(cars_lm, threshold = "baseR")
#' Plot cook's distance graph
#'
#' @param fitted.lm a fitted linear model (i.e. lm, glm) that contains fitted regression
#' @param label logical; whether or not to label observation number larger than threshold.
#' Default to TRUE.
#' @param threshold string; determining the cut off label of cook's distance. Choices are
#' "baseR" (0.5 and 1), "matlab" (mean(cooksd)*3), and "convention" (4/n and 1). Default to "convention".
#' @return A ggplot object that contains a cook's distance plot
#' @examples library(MASS)
#' data(Cars93)
#' cars_lm <- lm(Price ~ Passengers + Length + RPM, data = Cars93)
#' gg_cooksd(cars_lm)
#'
#' @export
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention") {
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point() +
geom_linerange() +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 2, color = "indianred3")
}
if (show.threshold) {
if (min(threshold) > max_cook) {
message("cut-off for outliers too big to be shown in cook distance plot")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3")
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm, threshold = "baseR")
#' Plot cook's distance graph
#'
#' @param fitted.lm a fitted linear model (i.e. lm, glm) that contains fitted regression
#' @param label logical; whether or not to label observation number larger than threshold.
#' Default to TRUE.
#' @param threshold string; determining the cut off label of cook's distance. Choices are
#' "baseR" (0.5 and 1), "matlab" (mean(cooksd)*3), and "convention" (4/n and 1). Default to "convention".
#' @return A ggplot object that contains a cook's distance plot
#' @examples library(MASS)
#' data(Cars93)
#' cars_lm <- lm(Price ~ Passengers + Length + RPM, data = Cars93)
#' gg_cooksd(cars_lm)
#'
#' @export
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention") {
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
# compute the threshold value for cook's distance plot
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point() +
geom_linerange() +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
# labelling of potential outliers
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 2, color = "indianred3")
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3")
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm, threshold = "convention")
gg_cooksd(cars_lm, threshold = "matlab")
rlm(Price ~ Rev.per.mile, data = Cars93)
fortify(rlm(Price ~ Rev.per.mile, data = Cars93))
gg_resX(rlm(Price ~ Rev.per.mile, data = Cars93))
#' Generate residual plot of residuals against predictors
#'
#' @param fitted.lm a fitted linear model (i.e. lm, glm) that contains fitted regression
#' @param plotAll boolean value to determine whether plot will be return as
#' a plot arranged using `grid.arrange()`. When set to false, the function
#' would return a list of residual plots. Parameter defaults to TRUE.
#' @return An arranged grid of residuals against predictor values plots in ggplot.
#' If plotall is set to FALSE,  a list of ggplot objects will be returned instead.
#' Name of the plots are set to respective variable names.
#' @examples
#' library(MASS)
#' data(Cars93)
#' # a regression with categorical variable
#' cars_lm <- lm(Price ~ Passengers + Length + RPM + Origin, data = Cars93)
#' gg_resX(cars_lm, data = Cars93)
#' # customize which diagnostic plot is included by have gg_resX to return a list of plots
#' plots <- gg_resX(cars_lm, data = Cars93, plotAll = FALSE)
#' names(plots)     # get name of the plots
#' exclude_plots <- plots[-1 ]    #exclude certain residual plots
#' include_plots <- plots[1]      # include certain residual plots
#' plot_all(exclude_plots)              # make use of plot_all() in lindia
#' plot_all(include_plots)
#' @export
gg_resX <- function(fitted.lm, plotAll = TRUE){
#handle_exception(fitted.lm, "gg_resX")
# extract model matrix
lm_matrix = fortify(fitted.lm)
# extract relevant explanatory variables in model matrix
var_names = get_varnames(fitted.lm)$predictor
dim = length(var_names)
# create a list to hold all residual plots
plots = vector("list", dim)
# number of plots so far
n = 1
for (i in 1:length(var_names)){
var = var_names[i]
this_plot <- get_resplot(var, lm_matrix, fitted.lm)
if (!is.null(this_plot)) {
plots[[n]] <- this_plot
n = n + 1
}
}
# rename the plots
names(plots) = var_names
# determine to plot the plots, or return a list of plots
if (plotAll) {
nCol = get_ncol(dim)
return (do.call("gridExtra::grid.arrange", c(plots, ncol = nCol)))
}
else {
return (plots)
}
}
#
# get_resplot - returns a ggplot object of residuals in fitted.lm against var in lm_matrix
#
# input : var - variable name string the residual plot is about
#         lm_matrix - model matrix of the fitted lm
#        fitted.lm : fitted lm
#        data : original dataset (optional)
#
# output : a ggplot object of var vs. residual of fitted lm
#
get_resplot <- function(var, lm_matrix, fitted.lm){
# to center residual plot around y = 0 line
res = residuals(fitted.lm)
limit = max(abs(res))
margin_factor = 5
margin = round(limit / margin_factor)
n_var_threshold = 4    # if more number of variables than threshold, tilt label to 45 degrees
# handle categorical and continuous variables
x = lm_matrix[, var]
# continuous variable: return scatterplot
if (is.numeric(x)) {
return (ggplot(data = fitted.lm, aes(x = lm_matrix[, var], y = fitted.lm$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "indianred3") +
ylim(-(limit + margin), limit + margin))
}
# categorical variable: return boxplot
else {
base_plot = ggplot(data = data.frame(lm_matrix), aes(x = lm_matrix[, var], y = fitted.lm$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_boxplot()
if (nlevels(lm_matrix[, var]) > n_var_threshold) {
return (base_plot + theme(axis.text.x = element_text(angle = 45, hjust = 1)))
}
else {
return (base_plot)
}
return(base_plot)
}
}
gg_resX(rlm(Price ~ Rev.per.mile, data = Cars93))
#' Generate residual plot of residuals against predictors
#'
#' @param fitted.lm a fitted linear model (i.e. lm, glm) that contains fitted regression
#' @param plotAll boolean value to determine whether plot will be return as
#' a plot arranged using `grid.arrange()`. When set to false, the function
#' would return a list of residual plots. Parameter defaults to TRUE.
#' @return An arranged grid of residuals against predictor values plots in ggplot.
#' If plotall is set to FALSE,  a list of ggplot objects will be returned instead.
#' Name of the plots are set to respective variable names.
#' @examples
#' library(MASS)
#' data(Cars93)
#' # a regression with categorical variable
#' cars_lm <- lm(Price ~ Passengers + Length + RPM + Origin, data = Cars93)
#' gg_resX(cars_lm, data = Cars93)
#' # customize which diagnostic plot is included by have gg_resX to return a list of plots
#' plots <- gg_resX(cars_lm, data = Cars93, plotAll = FALSE)
#' names(plots)     # get name of the plots
#' exclude_plots <- plots[-1 ]    #exclude certain residual plots
#' include_plots <- plots[1]      # include certain residual plots
#' plot_all(exclude_plots)              # make use of plot_all() in lindia
#' plot_all(include_plots)
#' @export
gg_resX <- function(fitted.lm, plotAll = TRUE){
#handle_exception(fitted.lm, "gg_resX")
# extract model matrix
lm_matrix = fortify(fitted.lm)
# extract relevant explanatory variables in model matrix
var_names = get_varnames(fitted.lm)$predictor
dim = length(var_names)
# create a list to hold all residual plots
plots = vector("list", dim)
# number of plots so far
n = 1
for (i in 1:length(var_names)){
var = var_names[i]
this_plot <- get_resplot(var, lm_matrix, fitted.lm)
if (!is.null(this_plot)) {
plots[[n]] <- this_plot
n = n + 1
}
}
# rename the plots
names(plots) = var_names
# determine to plot the plots, or return a list of plots
if (plotAll) {
nCol = get_ncol(dim)
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return (plots)
}
}
#
# get_resplot - returns a ggplot object of residuals in fitted.lm against var in lm_matrix
#
# input : var - variable name string the residual plot is about
#         lm_matrix - model matrix of the fitted lm
#        fitted.lm : fitted lm
#        data : original dataset (optional)
#
# output : a ggplot object of var vs. residual of fitted lm
#
get_resplot <- function(var, lm_matrix, fitted.lm){
# to center residual plot around y = 0 line
res = residuals(fitted.lm)
limit = max(abs(res))
margin_factor = 5
margin = round(limit / margin_factor)
n_var_threshold = 4    # if more number of variables than threshold, tilt label to 45 degrees
# handle categorical and continuous variables
x = lm_matrix[, var]
# continuous variable: return scatterplot
if (is.numeric(x)) {
return (ggplot(data = fitted.lm, aes(x = lm_matrix[, var], y = fitted.lm$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "indianred3") +
ylim(-(limit + margin), limit + margin))
}
# categorical variable: return boxplot
else {
base_plot = ggplot(data = data.frame(lm_matrix), aes(x = lm_matrix[, var], y = fitted.lm$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_boxplot()
if (nlevels(lm_matrix[, var]) > n_var_threshold) {
return (base_plot + theme(axis.text.x = element_text(angle = 45, hjust = 1)))
}
else {
return (base_plot)
}
return(base_plot)
}
}
gg_resX(rlm(Price ~ Rev.per.mile, data = Cars93))
#' Plot cook's distance graph
#'
#' @param fitted.lm a fitted linear model (i.e. lm, glm) that contains fitted regression
#' @param label logical; whether or not to label observation number larger than threshold.
#' Default to TRUE.
#' @param threshold string; determining the cut off label of cook's distance. Choices are
#' "baseR" (0.5 and 1), "matlab" (mean(cooksd)*3), and "convention" (4/n and 1). Default to "convention".
#' @param show.threshold logical; determine whether or not threshold line is to be shown. Default to TRUE.
#' @return A ggplot object that contains a cook's distance plot
#' @examples library(MASS)
#' data(Cars93)
#' cars_lm <- lm(Price ~ Passengers + Length + RPM, data = Cars93)
#' gg_cooksd(cars_lm)
#'
#' @export
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention") {
#handle_exception(fitted.lm, "gg_cooksd")
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
# compute the threshold value for cook's distance plot
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point() +
geom_linerange() +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
# labelling of potential outliers
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 2, color = "indianred3")
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3")
}
}
}
return(base_plot)
}
gg_cooksd(rlm(Price ~ Rev.per.mile, data = Cars93))
getwd()
setwd("../Github/lindia")
devtools::document()
devtools::load_all()
cor(task.performance.score, rapport.score)
plot(task.performance.score, rapport.score, main = "Scatterplot of task performance score and rapport score")
devtools::install_github("yeukyul/lindia")
library(lindia)
?gg_diagnose
gmp <- read.csv("~/Desktop/Academic/S17/36402/HW/5/gmp.csv", stringsAsFactors=FALSE)
View(gmp)
gmp <- read.csv("http://www.stat.cmu.edu/~cshalizi/uADA/17/hw/05/gmp-2006.csv")
names(gmp)
head(gmp)
reg.line <- lm(log(pop) ~ log(pcgmp), data = gmp)
summary(reg.line)
# function form Cosma's lecture notes
coefs.gmp.lm <- function(df) {
fit <- lm(log(pop) ~ log(pcgmp), data = df)
return(coefficients(fit))
}
resample.data.frame <- function(df) {
return(df[resample(1:nrow(df)),])
}
gmp.lm.samp.dist.resids <- replicate(1000,
coefs.gmp.lm(sim.gmp.resids()))
apply(gmp.lm.samp.dist.resids,1,quantile,c(0.025,0.975))
sim.gmp.resids <- function() {
new.gmp <- gmp
noise <- resample(residuals(cats.lm))
new.gmp$pop <- exp(fitted(fitted.gmp) + noise)
return(new.gmp)
}
cats.lm.samp.dist.cases <- replicate(1000,
coefs.gmp.lm(resample.data.frame(gmp)))
apply(gmp.lm.samp.dist.cases,1,quantile,c(0.025,0.975))
# function form Cosma's lecture notes
coefs.gmp.lm <- function(df) {
fit <- lm(log(pop) ~ log(pcgmp), data = df)
return(coefficients(fit))
}
resample.data.frame <- function(df) {
return(df[resample(1:nrow(df)),])
}
gmp.lm.samp.dist.resids <- replicate(1000,
coefs.gmp.lm(sim.gmp.resids()))
apply(gmp.lm.samp.dist.resids,1,quantile,c(0.025,0.975))
sim.gmp.resids <- function() {
new.gmp <- gmp
noise <- resample(residuals(cats.lm))
new.gmp$pop <- exp(fitted(fitted.gmp) + noise)
return(new.gmp)
}
gmp.lm.samp.dist.cases <- replicate(1000,
coefs.gmp.lm(resample.data.frame(gmp)))
apply(gmp.lm.samp.dist.cases,1,quantile,c(0.025,0.975))
