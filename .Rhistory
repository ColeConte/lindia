}
if (plotAll) {
nCol = get_ncol(dim)
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return (plots)
}
}
gg_resX(cars_lm_2, data = Cars93)
gg_resX(cars_lm_2)
gg_resX(cars_lm_3)
gg_resX(cars_lm_3, data = Cars93)
gg_resX <- function(lm_object, data = NULL, select = NULL, plotAll = TRUE){
handle_exception(lm_object, "gg_resX")
# extract model matrix
model_matrix = model.matrix(lm_object)
# extract relevant explanatory variables in model matrix
var_names = get_varnames(lm_object)$predictor
dim = length(var_names)
cat_inds = c()
# if didn't pass in data, check how many categorical variables there are
if (is.null(data)) {
cat_inds = n_cat(var_names, model_matrix)
dim = dim - length(cat_inds)
}
# create a list to hold all residual plots
plots = vector("list", dim)
# number of plots so far
n = 1
for (i in 1:length(var_names)){
# if encounter categorical variable, skip
if (i %in% cat_inds) {
message(paste("Find categorical variable `", var_names[i],"`. Should pass in the dataset as 'data' parameter to allow plotting. Lindia igonore plot for now."))
next
}
var = var_names[i]
this_plot <- get_resplot(var, model_matrix, lm_object, data = data)
if (!is.null(this_plot)) {
plots[[n]] <- this_plot
n = n + 1
}
}
# rename plots in the array
if (length(cat_inds) > 0) {
names(plots) = var_names[-cat_inds]
}
else {
names(plots) = var_names
}
if (plotAll) {
nCol = get_ncol(dim)
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return (plots)
}
}
#
# n_cat returns the index of categorical varible in given regression
#
n_cat <- function(varnames, model_matrix) {
cat_inds = c()
modelvars = colnames(model_matrix)
for (i in 1:length(varnames)) {
name = varnames[i]
if (!(name %in% modelvars)) {
cat_inds = c(cat_inds, i)
}
}
return (cat_inds)
}
#
# get_resplot returns a ggplot object of residuals in lm_object against var in model_matrix
#
get_resplot <- function(var, model_matrix, lm_object, data){
# to center residual plot around y = 0 line
res = residuals(lm_object)
limit = max(abs(res))
margin_factor = 5
margin = round(limit / margin_factor)
# handle categorical and continuous variables
if (!is.null(data)) {
x = data[, var]
}
else {
x = model_matrix[, var]
}
# handle numeric variable
if (is.numeric(x)) {
return (ggplot(data = lm_object, aes(x = model_matrix[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "indianred3") +
ylim(-(limit + margin), limit + margin))
}
if (is.null(data)) {
message(paste("Find categorical variable '", var,"'. Should pass in the dataset as 'data' parameter to allow plotting. Lindia igonore plot for now."))
return (NULL)
}
else {
return (ggplot(data = data, aes(x = data[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_boxplot())
}
}
gg_resX(cars_lm_3, data = Cars93)
gg_resX(cars_lm_3)
gg_resX(cars_lm_4)
gg_resX(cars_lm_4, data = Cars93)
gg_resfitted(cars_lm_4)
plot(cars_lm_4)
l <- list()
class(l)
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = vector("list", n_plots - length(get_varnames(lm_object)[[1]]))
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
append(plots, gg_resX(lm_object, data = data)
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = vector("list", n_plots - length(get_varnames(lm_object)[[1]]))
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
append(plots, gg_resX(lm_object, data = data))
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm)
lm_object(cars_lm)
lm_object = cars_lm
plots = vector("list", n_plots - length(get_varnames(lm_object)[[1]]))
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
nCol = get_ncol(n_plots)
plots = vector("list", n_plots - length(get_varnames(lm_object)[[1]]))
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
append(plots, gg_resX(lm_object, data = data))
append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
gg_resX(lm_object, data = data, plotAll = FALSE)
gg_resX(lm_object, data = Cars93, plotAll = FALSE)
data = Cars93
append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
plots = vector("list", n_plots - length(get_varnames(lm_object)[[1]]))
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
do.call("grid.arrange", c(plots, ncol = nCol))
plots
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = vector("list", 6)
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
#plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm)
plots = vector("list", 6)
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
plots
plots = list()
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
plots
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = list()
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
#plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm)
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = list()
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["resX"]] <- gg_resX(lm_object, data = data)
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
#plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm)
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = list()
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm)
gg_diagnose(cars_lm_2)
gg_diagnose(cars_lm_2, data = Cars93)
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = list()
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
# apply style to all the plots
if (!(is.null(theme))) {
apply(plots, function(plot) { plot + theme })
}
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm, theme = theme_bw())
gg_diagnose <- function(lm_object, theme = NULL, ncol = NULL, include = NULL, exclude = NULL, data = NULL,
plotAll = TRUE) {
handle_exception(lm_object, "gg_diagnose")
# compute total number of diagnostic plots
n_plots = length(get_varnames(lm_object)[[1]])
n_plots = n_plots + 6
# compute the best dimension for resulting plot
if (!is.null(include)) {
nCol = get_ncol(length(include))
n_plot = length(include)
}
else if (!is.null(exclude)) {
nCol = n_plot - length(exclude)
}
else if (is.null(ncol)) {
nCol = get_ncol(n_plots)
}
else {
nCol = ncol
}
plots = list()
# get all plots
# !!!! not implemented: should ignore plots that cannot be generated
plots[["residual_hist"]] <- gg_reshist(lm_object)
plots = append(plots, gg_resX(lm_object, data = data, plotAll = FALSE))
plots[["res_fitted"]] <- gg_resfitted(lm_object)
plots[["gg_qqplot"]] <- gg_qqplot(lm_object)
plots[["gg_boxcox"]] <- gg_boxcox(lm_object)
plots[["gg_scalelocation"]] <- gg_scalelocation(lm_object)
plots[["gg_resleverage"]] <- gg_resleverage(lm_object)
# apply style to all the plots
if (!(is.null(theme))) {
plots = lapply(plots, function(plot) { plot + theme })
}
if (plotAll) {
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return(plots)
}
}
gg_diagnose(cars_lm, theme = theme_bw())
plots(gg_diagnose(cars_lm_2))
plots <- gg_diagnose(cars_lm_2)
plots <- gg_diagnose(cars_lm_2, plotAll = FALSE)
plot_all <- function(plots, ncol = NULL) {
if (class(plots) != "list") {
stop("plot_all() doesn't know how to handle non-list input")
}
if (is.null(ncol)) {
ncol = get_ncol(length(plots))
}
return (do.call("gridExtra::grid.arrange", c(plots, ncol = ncol)))
}
plot_all(plots)
plot_all <- function(plots, ncol = NULL) {
if (class(plots) != "list") {
stop("plot_all() doesn't know how to handle non-list input")
}
if (is.null(ncol)) {
ncol = get_ncol(length(plots))
}
return (do.call("grid.arrange", c(plots, ncol = ncol)))
}
plot_all(plots)
warning(paste("Find categorical variable `", var_names[i],"`. Should pass in the dataset as 'data' parameter to allow plotting. Lindia ignores plot for now."))
i = 1
var_names = c("hello world")
warning(paste("Find categorical variable `", var_names[i],"`. Should pass in the dataset as 'data' parameter to allow plotting. Lindia ignores plot for now."))
getwd()
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::load_all()
devtools::document()
