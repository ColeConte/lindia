geom_boxplot(fill = "grey80", colour = "blue") +
scale_x_discrete() + xlab("Groups") +
ylab("Searches ran") +
ggtitle("Number of searched by V1")
ggplot(data, aes(x = as.factor(group), y = V2)) +
geom_boxplot(fill = "grey80", colour = "blue") +
scale_x_discrete() + xlab("Groups") +
ylab("Searches ran") +
ggtitle("Number of Items requested by V2")
ggplot(data, aes(x = as.factor(group), y = V4)) +
geom_boxplot(fill = "grey80", colour = "blue") +
scale_x_discrete() + xlab("Groups") +
ylab("Searches ran") +
ggtitle("V4 by group")
##### click number
ggplot(data, aes(x = as.factor(group), y = V4)) +
geom_boxplot(fill = "grey80", colour = "blue") +
scale_x_discrete() + xlab("Groups") +
d
anova(lm(V1 ~ group, data = data))
anova(lm(email ~ group, data = data))
anova(lm(items ~ group, data = data))
anova(lm(item ~ group, data = data))
anova(lm(turns ~ group, data = data))
anova(lm(item ~ group, data = data))
anova(lm(V4 ~ group, data = data))
anova(lm(V3 ~ group, data = data))
anova(lm(V2 ~ group, data = data))
x = list(x = 1, y = 2)
x
y = x[-1]
y
#' Plot boxcox graph in ggplot with suggested lambda transformation and 95% confidence level.
#'
#' @param lm lm object that contains fitted regression
#' @param showlambda logical which controls whether lambda value should be displayed on graph. Defaults to TRUE
#' @param lambdaSF controls to how many significant figure is lambda rounded to. Defaults to 3.
#' @return A ggplot object that contains boxcox graph
#' @examples gg_boxcox()
#' @export
gg_boxcox <- function(lm_object, showlambda = TRUE, lambdaSF = 3){
handle_exception(lm_object, "gg_boxcox")
# compute boxcox graph points
boxcox_object <- boxcox(lm_object, plotit = FALSE)
# create new dataframe to hold all x and y points
x <- unlist(boxcox_object$x)
y <- unlist(boxcox_object$y)
# compute start and end of each line segment
xstart <- x[-1]
ystart <- y[-1]
xend <- x[-(length(x))]
yend <- y[-(length(y))]
boxcox_unlist <- data.frame(xstart, ystart, xend, yend)
# obtain best lamda
best_lambda <- x[which.max(y)]
rounded_lambda <- round(best_lambda, lambdaSF)
min_y <- min(y)
# compute accepted range of lambda transformation
accept_range <- x[y > max(y) - 1/2 * qchisq(.95,1)]
conf_lo <- round(min(accept_range), lambdaSF)
conf_hi <- round(max(accept_range), lambdaSF)
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
labs(x = "lambda", y = "log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted") +
geom_vline(xintercept = conf_lo, linetype = "dotted") +
geom_vline(xintercept = conf_hi, linetype = "dotted")
# add label if show lambda range
if (showlambda) {
return(plot +
geom_text(aes(x = best_lambda, label = as.character(rounded_lambda), y = min_y), color = "indianred3") +
geom_text(aes(x = conf_lo, label = as.character(conf_lo), y = min_y)) +
geom_text(aes(x = conf_hi, label = as.character(conf_hi), y = min_y)))
}
else {
return (plot)
}
}
library(MASS)
data(Cars93)
cars_lm <- lm(Rev.per.mile ~ Passengers + Length + RPM, data = Cars93)
cars_lm_2 <- lm(Rev.per.mile ~ Passengers + Length + RPM + Manufacturer, data = Cars93)
cars_lm_3 <- lm(Rev.per.mile ~ Passengers + Length + RPM + Manufacturer + Weight * Length, data = Cars93)
cars_lm_4 <- lm(Rev.per.mile ~ Passengers + Length + RPM + Manufacturer + Type + Make * Origin , data = Cars93)
gg_boxcox(cars_lm)
# This file contains general helper functions used in lindia
# strsplit_vec - splits a string and returns a vector
#
# input: str - string to be splitted
#        split - character to be splitted by
# output: a vector as a result of string splitting
#
strsplit_vec <- function(str, split) {
return (unlist(strsplit(str, split))[-1])
}
#
# get_resplot - returns a ggplot object of residuals in lm_object against var in model_matrix
#
# input : var - variable name string the residual plot is about
#         model_matrix - model matrix of the fitted lm
#        lm_object : fitted lm
#        data : original dataset (optional)
#
# output : a ggplot object of var vs. residual of fitted lm
#
get_resplot <- function(var, model_matrix, lm_object, data){
# to center residual plot around y = 0 line
res = residuals(lm_object)
limit = max(abs(res))
margin_factor = 5
margin = round(limit / margin_factor)
n_var_threshold = 4    # if more number of variables than threshold, tilt label to 45 degrees
# handle categorical and continuous variables
if (!is.null(data)) {
x = data[, var]
}
else {
x = model_matrix[, var]
}
# handle numeric variable
if (is.numeric(x)) {
return (ggplot(data = lm_object, aes(x = model_matrix[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "indianred3") +
ylim(-(limit + margin), limit + margin))
}
if (is.null(data)) {
message(paste("Find categorical variable '", var,"'. Should pass in the dataset as 'data' parameter to allow plotting. Lindia igonore plot for now."))
return (NULL)
}
else {
base_plot = ggplot(data = data, aes(x = data[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_boxplot()
#       if (unique(data[, var]) > n_var_threshold) {
#          return (base_plot + theme(axis.text.x = element_text(angle = 45, hjust = 1)))
#       }
#       else {
#          return (base_plot)
#       }
return(base_plot)
}
}
#
# n_cat - returns the index of categorical varible in given regression
#
# input : varnames - vector of variable name strings
#         model_matrix - model_matrix of the fitted lm
# output : index of categorical varible in given regression
#
n_cat <- function(varnames, model_matrix) {
cat_inds = c()
modelvars = colnames(model_matrix)
for (i in 1:length(varnames)) {
name = varnames[i]
if (!(name %in% modelvars)) {
cat_inds = c(cat_inds, i)
}
}
return (cat_inds)
}
#
# get_ncols - returns the appropriate number of columns to arrange number of plots
#              into a square display grid. ncol returned would at least be 1.
#
# input : n_plots - number of plots
# output : a number represents number of column needed to organize the plots into a square grid
#
get_ncol <- function(n_plots) {
return(max(floor(sqrt(n_plots)), 1))
}
#
# get_varnames - returns variable names in a lm.
#
# input : lm_object - fitted lm
# output : list of two items
#                    [[1]] : string variable names in fitted lm
#                    [[2]] : vector of interaction terms
#
get_varnames <- function(lm_object) {
lm_formula = as.character(formula(lm_object))
var_names_list = strsplit(lm_formula, ' ~ ')
var_name_vec = strsplit_vec(lm_formula, ' ~ ')
# drop response variable
args_str = var_name_vec
# parse args in lm
args = unlist(strsplit_vec(args_str, " \\+ "))
n_args = length(args)
predictors = c()
interaction = list()
# count how many interaction terms there are
# used for storing variables in return list
n_inter = 1
# find interaction terms
for (i in 1:n_args) {
term = args[i]
# check if it is interaction term
# !! caution: check if it works with multiple interaction
if (grepl(' \\* ', term)) {
inter_terms = unlist(strsplit(term, " \\* "))
predictors = c(predictors, inter_terms)
interaction[[n_inter]] = inter_terms
n_inter = n_inter + 1
}
else {
predictors = c(predictors, term)
}
}
# clean up duplicated predictors from extracting from interaction terms
predictors = unique(predictors)
return (list(predictors = predictors, interactions = interaction))
}
gg_boxcox(cars_lm)
# This file contains exception checking and error handling functions
#
# exception handling function for malformed input in lindia
#
handle_exception <- function(input, function_name){
# exception handling : input not lm object
if (class(input) != "lm"){
stop(paste(function_name, "doesn't know how to handle non-lm object"))
}
}
gg_boxcox(cars_lm)
lm_object = cars_lm
boxcox_object <- boxcox(lm_object, plotit = FALSE)
x <- unlist(boxcox_object$x)
y <- unlist(boxcox_object$y)
xstart <- x[-1]
ystart <- y[-1]
xend <- x[-(length(x))]
yend <- y[-(length(y))]
boxcox_unlist <- data.frame(xstart, ystart, xend, yend)
best_lambda <- x[which.max(y)]
rounded_lambda <- round(best_lambda, lambdaSF)
min_y <- min(y)
accept_range <- x[y > max(y) - 1/2 * qchisq(.95,1)]
accept_range
y > max(y) - 1/2 * qchisq(.95,1)
accept_inds <- which(y > max(y) - 1/2 * qchisq(.95,1))
accept_range <- x[accept_inds]
accept_inds
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
labs(x = "lambda", y = "log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted") +
geom_vline(xintercept = conf_lo, linetype = "dotted") +
geom_vline(xintercept = conf_hi, linetype = "dotted") +
geom_hline(yintercept = y[min(accept_inds)])
accept_inds <- which(y > max(y) - 1/2 * qchisq(.95,1))
accept_range <- x[accept_inds]
conf_lo <- round(min(accept_range), lambdaSF)
conf_hi <- round(max(accept_range), lambdaSF)
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
labs(x = "lambda", y = "log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted") +
geom_vline(xintercept = conf_lo, linetype = "dotted") +
geom_vline(xintercept = conf_hi, linetype = "dotted") +
geom_hline(yintercept = y[min(accept_inds)])
conf_lo <- round(min(accept_range), lambdaSF)
lambdaSF = 3
accept_inds <- which(y > max(y) - 1/2 * qchisq(.95,1))
accept_range <- x[accept_inds]
conf_lo <- round(min(accept_range), lambdaSF)
conf_hi <- round(max(accept_range), lambdaSF)
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
labs(x = "lambda", y = "log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted") +
geom_vline(xintercept = conf_lo, linetype = "dotted") +
geom_vline(xintercept = conf_hi, linetype = "dotted") +
geom_hline(yintercept = y[min(accept_inds)])
# add label if show lambda range
plot
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend)) +
labs(x = "lambda", y = "log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted") +
geom_vline(xintercept = conf_lo, linetype = "dotted") +
geom_vline(xintercept = conf_hi, linetype = "dotted") +
geom_hline(yintercept = y[min(accept_inds)], linetype = "dotted")
plot
getwd()
setwd("../../Github/lindia")
library(lindia)
plots <- gg_diagnose(cars_lm, plotAll = FALSE)
names(plots)
plots <- plots[-c(2, 5)]
names(plots)
plot_all(plots)
library(devtools)
devtools::load_all()
devtools::document()
devtools::document()
# This file contains general helper functions used in lindia
# strsplit_vec - splits a string and returns a vector
#
# input: str - string to be splitted
#        split - character to be splitted by
# output: a vector as a result of string splitting
#
strsplit_vec <- function(str, split) {
return (unlist(strsplit(str, split))[-1])
}
#
# get_resplot - returns a ggplot object of residuals in lm_object against var in model_matrix
#
# input : var - variable name string the residual plot is about
#         model_matrix - model matrix of the fitted lm
#        lm_object : fitted lm
#        data : original dataset (optional)
#
# output : a ggplot object of var vs. residual of fitted lm
#
get_resplot <- function(var, model_matrix, lm_object, data){
# to center residual plot around y = 0 line
res = residuals(lm_object)
limit = max(abs(res))
margin_factor = 5
margin = round(limit / margin_factor)
n_var_threshold = 4    # if more number of variables than threshold, tilt label to 45 degrees
# handle categorical and continuous variables
if (!is.null(data)) {
x = data[, var]
}
else {
x = model_matrix[, var]
}
# handle numeric variable
if (is.numeric(x)) {
return (ggplot(data = lm_object, aes(x = model_matrix[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_point() +
geom_hline(yintercept = 0, linetype = "dashed", color = "indianred3") +
ylim(-(limit + margin), limit + margin))
}
if (is.null(data)) {
message(paste("Find categorical variable '", var,"'. Should pass in the dataset as 'data' parameter to allow plotting. Lindia igonore plot for now."))
return (NULL)
}
else {
base_plot = ggplot(data = data, aes(x = data[, var], y = lm_object$residuals)) +
labs(x = var, y = "residuals") +
ggtitle(paste("Residual vs.", var)) +
geom_boxplot()
if (nlevels(data[, var]) > n_var_threshold) {
return (base_plot + theme(axis.text.x = element_text(angle = 45, hjust = 1)))
}
else {
return (base_plot)
}
return(base_plot)
}
}
#
# n_cat - returns the index of categorical varible in given regression
#
# input : varnames - vector of variable name strings
#         model_matrix - model_matrix of the fitted lm
# output : index of categorical varible in given regression
#
n_cat <- function(varnames, model_matrix) {
cat_inds = c()
modelvars = colnames(model_matrix)
for (i in 1:length(varnames)) {
name = varnames[i]
if (!(name %in% modelvars)) {
cat_inds = c(cat_inds, i)
}
}
return (cat_inds)
}
#
# get_ncols - returns the appropriate number of columns to arrange number of plots
#              into a square display grid. ncol returned would at least be 1.
#
# input : n_plots - number of plots
# output : a number represents number of column needed to organize the plots into a square grid
#
get_ncol <- function(n_plots) {
return(max(floor(sqrt(n_plots)), 1))
}
#
# get_varnames - returns variable names in a lm.
#
# input : lm_object - fitted lm
# output : list of two items
#                    [[1]] : string variable names in fitted lm
#                    [[2]] : vector of interaction terms
#
get_varnames <- function(lm_object) {
lm_formula = as.character(formula(lm_object))
var_names_list = strsplit(lm_formula, ' ~ ')
var_name_vec = strsplit_vec(lm_formula, ' ~ ')
# drop response variable
args_str = var_name_vec
# parse args in lm
args = unlist(strsplit_vec(args_str, " \\+ "))
n_args = length(args)
predictors = c()
interaction = list()
# count how many interaction terms there are
# used for storing variables in return list
n_inter = 1
# find interaction terms
for (i in 1:n_args) {
term = args[i]
# check if it is interaction term
# !! caution: check if it works with multiple interaction
if (grepl(' \\* ', term)) {
inter_terms = unlist(strsplit(term, " \\* "))
predictors = c(predictors, inter_terms)
interaction[[n_inter]] = inter_terms
n_inter = n_inter + 1
}
else {
predictors = c(predictors, term)
}
}
# clean up duplicated predictors from extracting from interaction terms
predictors = unique(predictors)
return (list(predictors = predictors, interactions = interaction))
}
#' Generate residual plot of residuals against predictors
#'
#' @param lm_object lm object that contains fitted regression
#' @param data original dataset
#' @param select vector represents all variables that wanted ot be included
#' in output. Default to all variables.
#' @param plotAll boolean value to determine whether plot will be return as
#' a plot arranged using `grid.arrange()`. When set to false, the function
#' would return a list of residual plots. Parameter defaults to TRUE.
#' @return A list of ggplot objects that contains residual plot
#' of residuals against predictor values
#' @examples gg_resX()
#'
#' @export
gg_resX <- function(lm_object, data = NULL, select = NULL, plotAll = TRUE){
handle_exception(lm_object, "gg_resX")
# extract model matrix
model_matrix = model.matrix(lm_object)
# extract relevant explanatory variables in model matrix
var_names = get_varnames(lm_object)$predictor
dim = length(var_names)
cat_inds = c()
# if didn't pass in data, check how many categorical variables there are
if (is.null(data)) {
cat_inds = n_cat(var_names, model_matrix)
dim = dim - length(cat_inds)
}
# create a list to hold all residual plots
plots = vector("list", dim)
# number of plots so far
n = 1
for (i in 1:length(var_names)){
# if encounter categorical variable, skip
if (i %in% cat_inds) {
warning(paste("Find categorical variable `", var_names[i],"`. Should pass in the dataset as 'data' parameter to allow plotting. Lindia ignores plot for now."))
next
}
var = var_names[i]
this_plot <- get_resplot(var, model_matrix, lm_object, data = data)
if (!is.null(this_plot)) {
plots[[n]] <- this_plot
n = n + 1
}
}
# rename plots in the array
if (length(cat_inds) > 0) {
names(plots) = var_names[-cat_inds]
}
else {
names(plots) = var_names
}
if (plotAll) {
nCol = get_ncol(dim)
return (do.call("grid.arrange", c(plots, ncol = nCol)))
}
else {
return (plots)
}
}
gg_resX(cars_lm_3, data = Cars93)
head(Cars93)
Cars_lm5 <- lm(Weight ~ o)
Cars_lm5 <- lm(Weight ~ Make + Origin, data = Cars93)
gg_resX(Cars_lm5, data = Cars93)
Cars_lm5 <- lm(Weight ~ Make + Origin + RPM, data = Cars93)
gg_resX(cars_lm_5, data = Cars93)
gg_resX(Cars_lm_5, data = Cars93)
gg_resX(Cars_lm5, data = Cars93)
cars_lm6 <- lm(Weight ~ RPM, data = Cars93)
gg_resX(cars_lm6)
Cars_lm5 <- lm(Weight ~ Make + RPM, data = Cars93)
gg_resX(Cars_lm5, data = Cars93)
gg_diagnose(Cars_lm5, data = Cars93)
head(Cars93)
Cars_lm5 <- lm(Weight ~ Origin + RPM, data = Cars93)
gg_diagnose(Cars_lm5, data = Cars93)
gg_diagnose(Cars_lm5, data = Cars93, ncol = 3)
devtools::load_all()
devtools::load_all()
