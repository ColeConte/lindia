lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 4, color = "indianred3")
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3", size = scale.factor)
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm)
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention", scale.factor = 0.5) {
handle_exception(fitted.lm, "gg_cooksd")
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
# compute the threshold value for cook's distance plot
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point(size = scale.factor) +
geom_linerange(size = scale.factor) +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
# labelling of potential outliers
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 4, color = "indianred3", size = scale.factor)
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3", size = scale.factor)
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm)
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention", scale.factor = 0.5) {
handle_exception(fitted.lm, "gg_cooksd")
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
# compute the threshold value for cook's distance plot
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point(size = scale.factor) +
geom_linerange(size = scale.factor) +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
# labelling of potential outliers
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 4, color = "indianred3", size = scale.factor)
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3", size = scale.factor*10)
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm)
gg_cooksd <- function(fitted.lm, label = TRUE, show.threshold = TRUE, threshold = "convention", scale.factor = 1) {
handle_exception(fitted.lm, "gg_cooksd")
# obtain linear model matrix
lm_matrix <- fortify(fitted.lm)
lm_matrix[, "rowname"] <- 1:nrow(lm_matrix)
# threshold for outliar
cooksd = lm_matrix[, ".cooksd"]
n = nrow(lm_matrix)
# compute the threshold value for cook's distance plot
if (threshold == "matlab") {
threshold = mean(cooksd) * 3
}
else if (threshold == "baseR") {
threshold = c(0.5, 1)
}
else if (threshold == "convention") {
threshold = c(4/n, 1)
}
else {
stop("invalid threshold specified for gg_cooksd")
}
# window limit
limit = max(cooksd)
margin_factor = 5
margin = round(limit / margin_factor)
max_cook = limit + margin
base_plot <- (ggplot(fitted.lm, aes(1:nrow(lm_matrix), .cooksd, ymin = 0, ymax = cooksd)) +
geom_point(size = scale.factor) +
geom_linerange(size = scale.factor) +
xlab("Observation Number") +
ylab("Cook's distance") +
ggtitle("Cook's Distance Plot") +
ylim(0, max_cook))
# labelling of potential outliers
if (label) {
out_inds <- which(cooksd < min(threshold))
lm_matrix[out_inds, "rowname"] <- rep("", length(out_inds))
base_plot = base_plot + geom_text(label = lm_matrix[, "rowname"], nudge_x = 3, color = "indianred3")
}
# showing threshold for outliers
if (show.threshold) {
if (min(threshold) > max_cook) {
message("Cut-off for outliers too big to be shown in Cook's Distance plot.")
}
else {
for (i in 1:length(threshold)) {
if (threshold[i] > max_cook) {
next
}
base_plot = base_plot + geom_hline(yintercept = threshold[i], linetype = "dashed", color = "indianred3", size = scale.factor)
}
}
}
return(base_plot)
}
gg_cooksd(cars_lm)
gg_boxcox <- function(fitted.lm, showlambda = TRUE, lambdaSF = 3, scale.factor = 0.5){
handle_exception(fitted.lm, "gg_boxcox")
# compute boxcox graph points
boxcox_object <- boxcox(fitted.lm, plotit = FALSE)
# create new dataframe to hold all x and y points
x <- unlist(boxcox_object$x)
y <- unlist(boxcox_object$y)
# compute start and end of each line segment
xstart <- x[-1]
ystart <- y[-1]
xend <- x[-(length(x))]
yend <- y[-(length(y))]
boxcox_unlist <- data.frame(xstart, ystart, xend, yend)
# obtain best lamda
best_lambda <- x[which.max(y)]
rounded_lambda <- round(best_lambda, lambdaSF)
min_y <- min(y)
# compute accepted range of lambda transformation
accept_inds <- which(y > max(y) - 1/2 * qchisq(.95,1))
accept_range <- x[accept_inds]
conf_lo <- round(min(accept_range), lambdaSF)
conf_hi <- round(max(accept_range), lambdaSF)
plot <- ggplot(data = boxcox_unlist) +
geom_segment(aes(x = xstart, y = ystart, xend = xend, yend = yend), size = scale.factor) +
labs(x = "Lambda", y = "Log-likelihood") +
ggtitle("Boxcox Plot") +
geom_vline(xintercept = best_lambda, linetype = "dotted", size = scale.factor/2) +
geom_vline(xintercept = conf_lo, linetype = "dotted", size = scale.factor/2) +
geom_vline(xintercept = conf_hi, linetype = "dotted", size = scale.factor/2) +
geom_hline(yintercept = y[min(accept_inds)], linetype = "dotted", size = scale.factor/2)
# add label if show lambda range
if (showlambda) {
return(plot +
geom_text(aes(x = best_lambda, label = as.character(rounded_lambda), y = min_y)) +
geom_text(aes(x = conf_lo, label = as.character(conf_lo), y = min_y), color = "indianred3") +
geom_text(aes(x = conf_hi, label = as.character(conf_hi), y = min_y), color = "indianred3"))
}
else {
return (plot)
}
}
gg_boxcox(cars_lm)
gg_reshist <- function(fitted.lm, bins = NULL) {
handle_exception(fitted.lm, "gg_reshist")
#obtain residual and fitted values from fitted.lm
res = data.frame(residuals = residuals(fitted.lm))
if (is.null(bins)) {
return (ggplot(data = res, aes(x = residuals)) + geom_histogram(color = "white") +
ggtitle("Histogram of Residuals") +
labs(x = "Residuals"))
}
else {
return (ggplot(data = res, aes(x = residuals)) + geom_histogram(color = "white", bins = bins) +
ggtitle("Histogram of Residuals") +
labs(x = "Residuals"))
}
}
gg_reshist(cars_lm)
devtools::load_all()
devtools::document()
gg_diagnose(cars_lm)
View(gg_diagnose)
View(gg_resfitted)
View(gg_resfitted)
install.packages(poLCA)
install.packages(poLCA)
install.packages("poLCA")
library(ggpairs)
?ggpairs
?ggpair
??ggpairs
library(GGally)
library(poLCA)
library(knitr)
data(cheating)
ggpairs(cheating)
ggpairs(cheating, title = "Pairs plot of cheating dataset")
shiny::runApp('~/GitHub/fce_visualizer')
dim(cheating)
head(cheating)
cheating.proportion <- sapply(cheating, 2, function(student) { print(class(student))})
cheating.proportion <- sapply(cheating, function(student) { print(class(student))})
cheating.proportion <- sapply(cheating, function(student) { ifelse(length(which(student == 1)) > 1, 1, 0) })
cheating.proportion
cheating.proportion <- apply(cheating, 2, function(student) { ifelse(length(which(student == 1)) > 1, 1, 0) })
cheating.proportion
cheating.proportion <- apply(cheating, 1, function(student) { ifelse(length(which(student == 1)) > 1, 1, 0) })
cheating.proportion
non_cheater <- which(cheating.proportion == 0)
cheating[non_cheater, ]
cheating.proportion <- apply(cheating, 1, function(student) { ifelse(length(which(student >= 1)) > 1, 1, 0) })
cheating.proportion
cheating.proportion <- apply(cheating, 1, function(student) { ifelse(sum(students) >= 1, 1, 0) })
cheating.proportion <- apply(cheating, 1, function(student) { ifelse(sum(student) >= 1, 1, 0) })
cheating.proportion
cheating.proportion <- apply(cheating, 1, function(student) { ifelse(sum(student[1:4]) >= 1, 1, 0) })
cheating.proportion
head(cheating)
tail(cheating)
view(cheating)
View(cheating)
library(poLCA)
summary(cheating)
cheating.proportion <- apply(cheating, 1, function(student) { sum(student[1:4]) })
cheating.proportion
cheating.multiple <- apply(cheating, 1, function(student) { ifelse(length(which(student) >= 1) >= 2, 1, 0) } )
cheating.multiple <- apply(cheating, 1, function(student) { ifelse(length(which(student >= 1)) >= 2, 1, 0) } )
cheating.multiple
kable(data.frame(once = length(which(cheating.count >= 1)) / nrow(cheating),
multiple = length(which(cheating.multiple > 1)) / nrow(cheating)),
col.names = c("Cheat at least once", "Multiple forms"))
cheating.count <- apply(cheating, 1, function(student) { sum(student[1:4]) })
cheating.multiple <- apply(cheating, 1, function(student) { ifelse(length(which(student >= 1)) >= 2, 1, 0) } )
kable(data.frame(once = length(which(cheating.count >= 1)) / nrow(cheating),
multiple = length(which(cheating.multiple == 1)) / nrow(cheating)),
col.names = c("Cheat at least once", "Multiple forms"))
help(cheating)
dim(cheating)
lie.exam.prop <- length(which(cheating$LIEEXAM == 1)) / nrow(cheating)
lie.exam.prop
lie.exam.prop <- get.prop(cheating$LIEEXAM)
get.prop <- function(vec) {
return(length(which(vec == 1)) / nrow(cheating))
}
fraud.prop <- get.prop(cheating$FRAUD)
fraud.prop
fraud.lieexam.prop <- length(which(lie.exam$FRAUD == 1)) / length(lie.exam)
lie.exam <- cheating[which(cheating$LIEEXAM), ]
fraud.lieexam.prop <- length(which(lie.exam$FRAUD == 1)) / length(lie.exam)
lie.exam <- cheating[which(cheating$LIEEXAM == 1), ]
fraud.lieexam.prop <- length(which(lie.exam$FRAUD == 1)) / length(lie.exam)
fraud.lieexam.prop
fraud.lieexam.prop <- length(which(lie.exam$FRAUD == 1)) / nrow(lie.exam)
fraud.lieexam.prop
cheat <- NULL
library(poLCA)
data(cheating)
head(cheating)
View(cheating)
cheating.modified <- cheating
cheating.modified <- apply(cheating[1:4, ], 2, function(col) { col + 1 })
head(cheating.modified)
cheating.modified <- apply(cheating[1:4, ], 2, function(col) { col - 1 })
head(cheating.modified)
cheating.modified$GPA <- cheating$GPA
cheating.modified <- apply(cheating[1:4, ], 2, function(col) { col - 1 })
summary(cheating.modified)
head(cheating.modified, GPA)
head(cheating.modified, 10)
head(cheating.modified, 30)
cheating.modified <- apply(cheating[, 1:4], 2, function(col) { col - 1 })
head(cheating.modified, 30)
cheating.modified$GPA <- cheating$GPA
head(cheating.modified)
cheating.modified <- sapply(cheating[, 1:4], 2, function(col) { col - 1 })
cheating.modified <- data.frame(apply(cheating[, 1:4], 2, function(col) { col - 1 }))
cheating.modified$GPA <- cheating$GPA
head(cheating.modified)
cheating.count <- apply(cheating.modified, 1, function(student) { sum(student[1:4]) })
cheating.multiple <- apply(cheating.modified, 1,
function(student) {
ifelse(length(which(student >= 1)) >= 2, 1, 0)
}
)
kable(data.frame(once = length(which(cheating.count >= 1)) / nrow(cheating),
multiple = length(which(cheating.multiple == 1)) / nrow(cheating)),
col.names = c("Cheat at least once", "Multiple forms"))
lie.exam.prop <- get.prop(cheating.modified$LIEEXAM)
fraud.prop <- get.prop(cheating.modified$FRAUD)
lie.exam <- cheating[which(cheating.modified$LIEEXAM == 1), ]
fraud.lieexam.prop <- length(which(lie.exam$FRAUD == 1)) / nrow(lie.exam)
kable(data.frame(lie.exam.prop, fraud.prop, fraud.lieexam.prop),
col.names = c("Lie in Exam", "Fraud", "Fraud given Lie in Exam"))
names(cheating)
latent.mdl <- poLCA(cbind(LIEEXAM, LIEPAPER, FRAUD, COPYEXAM)~1, data, nclass = 2)
latent.mdl <- poLCA(cbind(LIEEXAM, LIEPAPER, FRAUD, COPYEXAM)~1, cheating, nclass = 2)
names(latent.mdl)
kable(latent.mdl$probs)
latent.mdl$probs
class(latent.mdl$probs)
sapply(latent.mdl$probs, function(table) { kable(table) })
lapply(latent.mdl$probs, function(table) { kable(table) })
knitr::opts_chunk$set(cache = T, echo = TRUE, warning = F, message = F)
library(knitr)
library(poLCA)
library(GGally)
library(dplyr)
data(cheating)
l_ply(latent.mdl$probs, function(table) { kable(table) })
library(dplyr)
l_ply(latent.mdl$probs, function(table) { kable(table) })
laply(latent.mdl$probs, function(table) { kable(table) })
ldply(latent.mdl$probs, function(table) { kable(table) })
?poLCA
?kable
names(cheating)
?ggpairs
cheating.plot <- as.factor(cheating$LIEEXAM)
cheating.plot <- cheating
cheating.plot$LIEEXAM <- as.factor(cheating$LIEEXAM)
ggpairs(cheating.plot, title = "Pairs plot of cheating dataset")
cheating.plot <- cheating
for (i in 1:4) {
cheating.plot[, i] = as.factor(cheating.plot[, i])
}
ggpairs(cheating.plot, title = "Pairs plot of cheating dataset")
names(cheating.plot)
summary(cheating.plot)
names(latent.mdl)
latent.mdl$probs
latent.mdl$llik
latent.mdl$posterior
latent.mdl$probs.start.ok
latent.mdl$probs
?poLCA
latent.mdl$y
latent.mdl$x
latent.mdl$p
latent.mdl$p.se
latent.mdl <- poLCA(GPA ~ cbind(LIEEXAM, LIEPAPER, FRAUD, COPYEXAM),
cheating, nclass = 2, verbose = F)
latent.mdl <- poLCA(cheating$GPA ~ cbind(LIEEXAM, LIEPAPER, FRAUD, COPYEXAM),
cheating, nclass = 2, verbose = F)
latent.mdl <- poLCA(GPA ~ LIEEXAM + LIEPAPER + FRAUD + COPYEXAM,
cheating, nclass = 2, verbose = F)
getwd()
setwd("../../R")
setwd("./chart:d3_exploration")
devtools::create("animatebar")
setwd("animatebard")
setwd("animatebar")
htmlwidgets::scaffoldWidget("animatebar")
setwd("..")
devtools::create("sunburst")
setwd("sunburst")
htmlwidgets::scaffoldWidget("sunburst")
?readJSON
list.dirs()
src <- "data/flare.json"
data <- fromJSON(src)
library(jsonlite)
data <- fromJSON(src)
head(data)
flatten(data)
data <- stream_in(file(src))
data <- fromJSON(src)
data
names(data)
data$name
data$children
0.423 * 0.411 * 0.784 * 0.624
1- !
)
1- 0.08505167
0.983 * 0.917 * 0.963 * 0.818
1 - 0.71
names(latent.mdl)
latend.mdl$x
latent.mdl$x
?poLCA
latent.mdl$predclass
getwd()
setwd("../cloudwidget")
devtools::install()
devtools::install()
sampleData
list.dirs()
list.dirs("./sampleData")
sampleData <- read.table("sampleData/data.tsv", sep = "\t", header = T)
head(sampleData)
cloudwidget::cloudwidget(sampleData)
devtools::install()
cloudwidget::cloudwidget(sampleData)
devtools::install()
cloudwidget::cloudwidget(sampleData)
cloudwidget::cloudwidget(sampleData)
cloudwidget::cloudwidget(sampleData)
setwd("../sunburst")
devtools:install()
devtools::install()
list.dirs()
list.dirs("./data")
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
getwd()
list.dirs()
devtools::install()
sunburst::sunburst("data/flare.json")
getwd()
setwd("../cloudwidget/")
setwd("../cloudwidget/")
setwd("../sunburst/")
devtools::install()
devtools::install()
sunburst::sunburst("data/flare.json")
cloudwidget::cloudwidget(sampleData)
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
sunburst::sunburst("data/flare.json")
devtools::install()
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
getwd()
library(sunburst)
sunburst(src)
src
cloudwidget::cloudwidget(sampleData)
devtools::install()
sunburst::sunburst("data/flare.json")
devtools::install()
sunburst::sunburst("data/flare.json")
